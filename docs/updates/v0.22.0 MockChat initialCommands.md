# âœ¨ Enhancement: Pre-register Commands in `ChatMock` testing with `initialCommandsToAdd`

_No breaking changes_

This update introduces a new configuration option, `initialCommandsToAdd`, within the `botSettings` of the `ChatMock` constructor. This feature allows you to pre-register commands (both `Normal` and `Tag` types) into the mocked bot instance before your test simulation begins.

This is particularly useful for testing commands that might interact with or depend on other commands being available within the bot's `CommandsSearcher`.

---

# The problem (old behavior)

Let's say you want to create a `!help` command, which will list all available commands in your
bot. You'll need to access to all bot commands to access to their information.

In your normal implementation it works, but... when you try to retrieve current Bot Commands (`Normal` and `Tag` ones), its empty!

```ts
import { expect, test } from "your-testing-framework";
import type { AdditionalAPI, CommandArgs, IChatContext } from "./index.js";
import { type ICommand, ChatMock } from "./index.js";

test("Before update...", async () => {
  class MyComWithoutExpect implements ICommand {
    name: string = "command";
    public async run(_ctx: IChatContext, api: AdditionalAPI, _args: CommandArgs): Promise<void> {
      console.log(api.Myself.Bot.Commands.NormalCommands); // Empty array []
      console.log(api.Myself.Bot.Commands.TagCommands); // Empty array []

      expect(api.Myself.Bot.Commands.NormalCommands).toHaveLength(0);
      expect(api.Myself.Bot.Commands.TagCommands).toHaveLength(0);
    }
  }
  const chat = new ChatMock(new MyComWithoutExpect(), {
    /** There's no option to provide bot command already registered! */
  });
  await chat.StartChatSimulation();
});
```

## The Solution (New Behavior)

Now `ChatMock` accepts a new property config called `initialCommandsToAdd` and are accessible from inside
your command code!

```ts
import { expect, test } from "bun:test";
import type { AdditionalAPI, CommandArgs, IChatContext } from "./index.js";
import { type ICommand, ChatMock, CommandType } from "./index.js";

test("After update...", async () => {
  class MyComWithoutExpect implements ICommand {
    name: string = "command";
    public async run(_ctx: IChatContext, api: AdditionalAPI, _args: CommandArgs): Promise<void> {
      console.log(api.Myself.Bot.Commands.NormalCommands); // [{..}] 'Command1_Normal' Obj
      console.log(api.Myself.Bot.Commands.TagCommands); // [{...}] 'Command2_Tag' Obj

      expect(api.Myself.Bot.Commands.NormalCommands).toHaveLength(1);
      expect(api.Myself.Bot.Commands.TagCommands).toHaveLength(1);
    }
  }

  const chat = new ChatMock(new MyComWithoutExpect(), {
    botSettings: {
      initialCommandsToAdd: [
        {
          commandType: CommandType.Normal,
          command: {
            name: "Command1_Normal",
            async run(_ctx, _api, _args) {},
          },
        },
        {
          commandType: CommandType.Tag,
          command: {
            name: "Command2_Tag",
            async run(_ctx, _api, _args) {},
          },
        },
      ],
    },
  });

  await chat.StartChatSimulation();
});
```

This was a feature I forgot to add but I started to need when implementing this library in real use cases.

Thanks for using `Whatsbotcord.js` and happy codding!
