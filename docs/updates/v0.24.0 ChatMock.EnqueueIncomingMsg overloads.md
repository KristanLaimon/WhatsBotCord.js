Hi again everyone, here a small update with a `SMALL BREAKING CHANGE`.

# ChatMock.EnqueueIncoming_Img() Overloads

The `EnqueueIncoming_Img` method simulates an incoming image message, adding it to the queue for the command under test to consume. It has been updated with flexible overloads to simplify test creation.

## Overloads

This method provides two convenient ways to simulate image messages:

### 1. `EnqueueIncoming_Img(imgUrl: string, opts?: MockEnqueueParamsMultimedia)`

This overload simulates an image from a specific URL or local file path. It is ideal for tests where the image source is important.

- **`imgUrl`**: The URL or path to the image file.
- **`opts`**: An optional object to specify a `caption`, `pushName`, or mock the download buffer.

### 2. `EnqueueIncoming_Img(opts?: MockEnqueueParamsMultimedia)`

This overload simulates a generic, default placeholder image (`./whatsbotcord-mock-img.png`). It is useful when the specific image content is not relevant to the test logic.

- **`opts`**: An optional object to specify a `caption`, `pushName`, or mock the download buffer.
- This method can be called with no arguments to simulate a basic image message.

---

## Multimedia Mocking (Breaking Change)

The `bufferToReturnOn_WaitMultimedia` option has been renamed to `imgContentBufferMocked`. This option allows you to specify a `Buffer` that `ctx.WaitMultimedia()` will resolve with, which is essential for testing multimedia handling logic without performing actual downloads.

---

## Usage Examples & Test Scenarios

Below are realistic examples of how to use `EnqueueIncoming_Img` within a test suite.

### Example 1: Simulating an Image from a URL

This test uses the first overload to simulate an incoming image from a specific URL with a caption. The command then verifies that it received the correct message details.

```typescript
test("should process an image from a specific URL", async () => {
  const imageUrl = "https://example.com/photo.jpg";

  class MyImageProcessor implements ICommand {
    name: string = "process";
    async run(ctx: IChatContext): Promise<void> {
      // The command waits for an image message
      const img = await ctx.WaitMsg(MsgType.Image);

      // Assertions inside the command
      expect(img).toBeDefined();
      expect(img!.message?.imageMessage?.url).toBe(imageUrl);
      expect(img!.message?.imageMessage?.caption).toBe("A beautiful landscape");
      expect(img!.pushName).toBe("TestUser");

      await ctx.SendText("Image processed successfully!");
    }
  }

  const chat = new ChatMock(new MyImageProcessor());

  // Enqueue the image message before starting the simulation
  chat.EnqueueIncoming_Img(imageUrl, {
    caption: "A beautiful landscape",
    pushName: "TestUser",
  });

  await chat.StartChatSimulation();

  // Verify the command's output
  expect(chat.SentFromCommand.Texts[0]?.text).toBe("Image processed successfully!");
});
```

### Example 2: Mocking the Multimedia Download

This test demonstrates how to use the `imgContentBufferMocked` option to test logic that relies on `ctx.WaitMultimedia()` without performing a real download.

```typescript
test("should use the mocked buffer for multimedia download", async () => {
  const mockBuffer = Buffer.from("this-is-a-fake-image-buffer");

  class MyDownloader implements ICommand {
    name: string = "download";
    async run(ctx: IChatContext): Promise<void> {
      // The command waits for the image's buffer directly
      const buffer = await ctx.WaitMultimedia(MsgType.Image);

      // The buffer should be the one we provided in the mock setup
      expect(buffer).toBe(mockBuffer);
      expect(buffer?.toString()).toBe("this-is-a-fake-image-buffer");

      await ctx.SendText("Buffer verified!");
    }
  }

  const chat = new ChatMock(new MyDownloader());

  // Enqueue an image and provide a mock buffer to be returned by WaitMultimedia
  chat.EnqueueIncoming_Img({
    imgContentBufferMocked: mockBuffer,
  });

  await chat.StartChatSimulation();

  expect(chat.SentFromCommand.Texts[0]?.text).toBe("Buffer verified!");
});
```

This update is more a quality of life update to improve readibility and developer experience with mocking framework included with whatsbotcord.

Happy coding!
